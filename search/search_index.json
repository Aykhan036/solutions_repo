{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion: Range vs. Angle of Projection \u2013 An In-Depth Perspective Introduction: The Physics Behind the Arc Projectile motion is a cornerstone of classical mechanics, offering a window into how forces shape the motion of objects through space. Whether launching a basketball into a hoop or sending a probe to Mars, the same physical laws apply. This discussion focuses on the trajectory of projectiles and specifically how the range is influenced by the angle of launch. By dissecting the core physics, exploring analytical methods, and considering modern computational techniques, we uncover the profound elegance behind motion through the air. 1. Theoretical Framework: Building the Mathematical Model We begin by applying Newton\u2019s laws to a two-dimensional motion scenario, where the only acting force is gravity. The acceleration vector is constant and directed downward, defined as: \\[ \\vec{a} = (0, -g) \\] Solving the second-order differential equations for position and velocity, we derive: \\[ v_x(t) = v_0 \\cos(\\theta) \\] \\[ v_y(t) = v_0 \\sin(\\theta) - gt \\] Upon integrating, we obtain the position functions: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] These equations trace the parabolic path of any projectile launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) . 2. Range Optimization: A Quantitative Analysis The horizontal distance traveled, or range \\(R\\) , is derived under the condition that the projectile returns to its original height: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This result highlights several key insights: The range is maximized at a launch angle of \\(45^\\circ\\) . Increasing the initial velocity has a quadratic effect on the range. The gravitational constant \\(g\\) inversely affects how far the object travels. 3. Applications in the Real World: From Theory to Practice The principles of projectile motion extend far beyond academic examples: Sports : Analyzing the best angles for throws or kicks improves performance. Defense Systems : Trajectory calculations guide targeting and impact predictions. Engineering : Used in everything from sprinkler design to drone movement. Aerospace : Space agencies model interplanetary transfers using advanced variations of projectile theory. 4. Computational Simulations: From Ideal to Realistic Ideal models often ignore crucial factors. To better mimic reality, simulations incorporate: Air drag , which decelerates the projectile. Altitude-dependent gravity , especially relevant for high-altitude or space-bound motion. Wind forces , introducing asymmetry into the trajectory. Digital terrain mapping , to simulate impacts on realistic landscapes. Toward Precision: Extending the Model\u2019s Scope Advanced simulations may integrate: Dynamic drag coefficients responsive to changes in velocity and air properties. Rotational forces like the Magnus effect, which alter the path of spinning objects. Earth\u2019s rotation via the Coriolis force, critical for long-range ballistic trajectories. Sophisticated numerical solvers , such as Runge-Kutta, to handle non-linear systems. Conclusion: Uncovering the Layers of Motion What begins as a simple parabolic flight evolves into a complex, multifaceted problem when extended to real-world contexts. Through theory, application, and simulation, projectile motion provides a powerful framework for understanding and predicting motion in both natural and engineered systems. Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) v0 = 30 # initial velocity (m/s) angles_deg = np.array([15, 30, 45, 60, 75]) # angles in degrees colors = ['b', 'g', 'r', 'c', 'm'] # for plotting # Time of flight function def time_of_flight(v0, theta): return (2 * v0 * np.sin(theta)) / g # Trajectory function def trajectory(v0, theta, t): x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y # 1. Plot trajectories for various angles plt.figure(figsize=(10, 6)) for angle_deg, color in zip(angles_deg, colors): theta = np.radians(angle_deg) t_flight = time_of_flight(v0, theta) t = np.linspace(0, t_flight, num=100) x, y = trajectory(v0, theta, t) plt.plot(x, y, label=f\"{angle_deg}\u00b0\", color=color) plt.title(\"Projectile Trajectories at Different Launch Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show() # 2. Range vs. Angle plot angles = np.radians(np.linspace(0, 90, 500)) ranges = (v0**2 * np.sin(2 * angles)) / g plt.figure(figsize=(10, 5)) plt.plot(np.degrees(angles), ranges, color='darkorange') plt.title(\"Range vs. Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.axvline(45, linestyle='--', color='gray', label='Maximum Range (45\u00b0)') plt.legend() plt.show() colab Mechanic","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-range-vs-angle-of-projection-an-in-depth-perspective","text":"","title":"Projectile Motion: Range vs. Angle of Projection \u2013 An In-Depth Perspective"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction-the-physics-behind-the-arc","text":"Projectile motion is a cornerstone of classical mechanics, offering a window into how forces shape the motion of objects through space. Whether launching a basketball into a hoop or sending a probe to Mars, the same physical laws apply. This discussion focuses on the trajectory of projectiles and specifically how the range is influenced by the angle of launch. By dissecting the core physics, exploring analytical methods, and considering modern computational techniques, we uncover the profound elegance behind motion through the air.","title":"Introduction: The Physics Behind the Arc"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-framework-building-the-mathematical-model","text":"We begin by applying Newton\u2019s laws to a two-dimensional motion scenario, where the only acting force is gravity. The acceleration vector is constant and directed downward, defined as: \\[ \\vec{a} = (0, -g) \\] Solving the second-order differential equations for position and velocity, we derive: \\[ v_x(t) = v_0 \\cos(\\theta) \\] \\[ v_y(t) = v_0 \\sin(\\theta) - gt \\] Upon integrating, we obtain the position functions: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] These equations trace the parabolic path of any projectile launched with an initial speed \\(v_0\\) at an angle \\(\\theta\\) .","title":"1. Theoretical Framework: Building the Mathematical Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-range-optimization-a-quantitative-analysis","text":"The horizontal distance traveled, or range \\(R\\) , is derived under the condition that the projectile returns to its original height: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This result highlights several key insights: The range is maximized at a launch angle of \\(45^\\circ\\) . Increasing the initial velocity has a quadratic effect on the range. The gravitational constant \\(g\\) inversely affects how far the object travels.","title":"2. Range Optimization: A Quantitative Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-applications-in-the-real-world-from-theory-to-practice","text":"The principles of projectile motion extend far beyond academic examples: Sports : Analyzing the best angles for throws or kicks improves performance. Defense Systems : Trajectory calculations guide targeting and impact predictions. Engineering : Used in everything from sprinkler design to drone movement. Aerospace : Space agencies model interplanetary transfers using advanced variations of projectile theory.","title":"3. Applications in the Real World: From Theory to Practice"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-computational-simulations-from-ideal-to-realistic","text":"Ideal models often ignore crucial factors. To better mimic reality, simulations incorporate: Air drag , which decelerates the projectile. Altitude-dependent gravity , especially relevant for high-altitude or space-bound motion. Wind forces , introducing asymmetry into the trajectory. Digital terrain mapping , to simulate impacts on realistic landscapes.","title":"4. Computational Simulations: From Ideal to Realistic"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#toward-precision-extending-the-models-scope","text":"Advanced simulations may integrate: Dynamic drag coefficients responsive to changes in velocity and air properties. Rotational forces like the Magnus effect, which alter the path of spinning objects. Earth\u2019s rotation via the Coriolis force, critical for long-range ballistic trajectories. Sophisticated numerical solvers , such as Runge-Kutta, to handle non-linear systems.","title":"Toward Precision: Extending the Model\u2019s Scope"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion-uncovering-the-layers-of-motion","text":"What begins as a simple parabolic flight evolves into a complex, multifaceted problem when extended to real-world contexts. Through theory, application, and simulation, projectile motion provides a powerful framework for understanding and predicting motion in both natural and engineered systems.","title":"Conclusion: Uncovering the Layers of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) v0 = 30 # initial velocity (m/s) angles_deg = np.array([15, 30, 45, 60, 75]) # angles in degrees colors = ['b', 'g', 'r', 'c', 'm'] # for plotting # Time of flight function def time_of_flight(v0, theta): return (2 * v0 * np.sin(theta)) / g # Trajectory function def trajectory(v0, theta, t): x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y # 1. Plot trajectories for various angles plt.figure(figsize=(10, 6)) for angle_deg, color in zip(angles_deg, colors): theta = np.radians(angle_deg) t_flight = time_of_flight(v0, theta) t = np.linspace(0, t_flight, num=100) x, y = trajectory(v0, theta, t) plt.plot(x, y, label=f\"{angle_deg}\u00b0\", color=color) plt.title(\"Projectile Trajectories at Different Launch Angles\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.legend() plt.grid(True) plt.show() # 2. Range vs. Angle plot angles = np.radians(np.linspace(0, 90, 500)) ranges = (v0**2 * np.sin(2 * angles)) / g plt.figure(figsize=(10, 5)) plt.plot(np.degrees(angles), ranges, color='darkorange') plt.title(\"Range vs. Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.axvline(45, linestyle='--', color='gray', label='Maximum Range (45\u00b0)') plt.legend() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Mechanic","title":"colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Probelm whit pandelon import numpy as np import matplotlib.pyplot as plt # Common parameters g = 9.81 # gravity L = 1.0 # length dt = 0.01 T = 50 steps = int(T/dt) t = np.linspace(0, T, steps) # Initial conditions theta0 = 0.2 omega0 = 0 def d2theta_dt2(theta, omega_dot, t, b, A, omega_drive): return -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega_drive * t) def run_simulation(b, A, omega_drive): theta = np.zeros(steps) omega_dot = np.zeros(steps) theta[0] = theta0 omega_dot[0] = omega0 for i in range(steps-1): k1_omega = dt * d2theta_dt2(theta[i], omega_dot[i], t[i], b, A, omega_drive) k1_theta = dt * omega_dot[i] k2_omega = dt * d2theta_dt2(theta[i] + 0.5*k1_theta, omega_dot[i] + 0.5*k1_omega, t[i] + 0.5*dt, b, A, omega_drive) k2_theta = dt * (omega_dot[i] + 0.5*k1_omega) k3_omega = dt * d2theta_dt2(theta[i] + 0.5*k2_theta, omega_dot[i] + 0.5*k2_omega, t[i] + 0.5*dt, b, A, omega_drive) k3_theta = dt * (omega_dot[i] + 0.5*k2_omega) k4_omega = dt * d2theta_dt2(theta[i] + k3_theta, omega_dot[i] + k3_omega, t[i] + dt, b, A, omega_drive) k4_theta = dt * (omega_dot[i] + k3_omega) omega_dot[i+1] = omega_dot[i] + (1/6)*(k1_omega + 2*k2_omega + 2*k3_omega + k4_omega) theta[i+1] = theta[i] + (1/6)*(k1_theta + 2*k2_theta + 2*k3_theta + k4_theta) return theta, omega_dot # ------------------------------- # 4 SCENARIOS # ------------------------------- scenarios = { \"Pure Pendulum (no damping, no forcing)\": {'b': 0, 'A': 0, 'omega_drive': 0}, \"Damped Pendulum (b>0, A=0)\": {'b': 0.2, 'A': 0, 'omega_drive': 0}, \"Forced Pendulum (b=0, A>0)\": {'b': 0, 'A': 1.2, 'omega_drive': 2/3}, \"Damped + Forced (resonance-ish)\": {'b': 0.2, 'A': 1.2, 'omega_drive': 2/3}, } # --- Plotting --- fig1, axs1 = plt.subplots(2, 2, figsize=(14, 8)) fig2, axs2 = plt.subplots(2, 2, figsize=(14, 8)) axs1 = axs1.flatten() axs2 = axs2.flatten() for idx, (title, params) in enumerate(scenarios.items()): theta, omega_dot = run_simulation(params['b'], params['A'], params['omega_drive']) # Plot 1: Angle vs Time axs1[idx].plot(t, theta) axs1[idx].set_title(title) axs1[idx].set_xlabel('Time (s)') axs1[idx].set_ylabel('Angle (rad)') axs1[idx].grid(True) # Plot 2: Phase Diagram (theta vs omega_dot) axs2[idx].plot(theta, omega_dot) axs2[idx].set_title(title) axs2[idx].set_xlabel('Angle (rad)') axs2[idx].set_ylabel('Angular Velocity (rad/s)') axs2[idx].grid(True) fig1.suptitle('Angle vs Time for Different Scenarios', fontsize=16) fig2.suptitle('Phase Diagrams (\u03b8 vs \u03c9) for Different Scenarios', fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() [My colab code] https://colab.research.google.com/drive/1w2VFAx_vHqH_MjsYttkpVH8_P_HGvs81?usp=sharing","title":"Probelm whit pandelon"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#probelm-whit-pandelon","text":"import numpy as np import matplotlib.pyplot as plt # Common parameters g = 9.81 # gravity L = 1.0 # length dt = 0.01 T = 50 steps = int(T/dt) t = np.linspace(0, T, steps) # Initial conditions theta0 = 0.2 omega0 = 0 def d2theta_dt2(theta, omega_dot, t, b, A, omega_drive): return -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega_drive * t) def run_simulation(b, A, omega_drive): theta = np.zeros(steps) omega_dot = np.zeros(steps) theta[0] = theta0 omega_dot[0] = omega0 for i in range(steps-1): k1_omega = dt * d2theta_dt2(theta[i], omega_dot[i], t[i], b, A, omega_drive) k1_theta = dt * omega_dot[i] k2_omega = dt * d2theta_dt2(theta[i] + 0.5*k1_theta, omega_dot[i] + 0.5*k1_omega, t[i] + 0.5*dt, b, A, omega_drive) k2_theta = dt * (omega_dot[i] + 0.5*k1_omega) k3_omega = dt * d2theta_dt2(theta[i] + 0.5*k2_theta, omega_dot[i] + 0.5*k2_omega, t[i] + 0.5*dt, b, A, omega_drive) k3_theta = dt * (omega_dot[i] + 0.5*k2_omega) k4_omega = dt * d2theta_dt2(theta[i] + k3_theta, omega_dot[i] + k3_omega, t[i] + dt, b, A, omega_drive) k4_theta = dt * (omega_dot[i] + k3_omega) omega_dot[i+1] = omega_dot[i] + (1/6)*(k1_omega + 2*k2_omega + 2*k3_omega + k4_omega) theta[i+1] = theta[i] + (1/6)*(k1_theta + 2*k2_theta + 2*k3_theta + k4_theta) return theta, omega_dot # ------------------------------- # 4 SCENARIOS # ------------------------------- scenarios = { \"Pure Pendulum (no damping, no forcing)\": {'b': 0, 'A': 0, 'omega_drive': 0}, \"Damped Pendulum (b>0, A=0)\": {'b': 0.2, 'A': 0, 'omega_drive': 0}, \"Forced Pendulum (b=0, A>0)\": {'b': 0, 'A': 1.2, 'omega_drive': 2/3}, \"Damped + Forced (resonance-ish)\": {'b': 0.2, 'A': 1.2, 'omega_drive': 2/3}, } # --- Plotting --- fig1, axs1 = plt.subplots(2, 2, figsize=(14, 8)) fig2, axs2 = plt.subplots(2, 2, figsize=(14, 8)) axs1 = axs1.flatten() axs2 = axs2.flatten() for idx, (title, params) in enumerate(scenarios.items()): theta, omega_dot = run_simulation(params['b'], params['A'], params['omega_drive']) # Plot 1: Angle vs Time axs1[idx].plot(t, theta) axs1[idx].set_title(title) axs1[idx].set_xlabel('Time (s)') axs1[idx].set_ylabel('Angle (rad)') axs1[idx].grid(True) # Plot 2: Phase Diagram (theta vs omega_dot) axs2[idx].plot(theta, omega_dot) axs2[idx].set_title(title) axs2[idx].set_xlabel('Angle (rad)') axs2[idx].set_ylabel('Angular Velocity (rad/s)') axs2[idx].grid(True) fig1.suptitle('Angle vs Time for Different Scenarios', fontsize=16) fig2.suptitle('Phase Diagrams (\u03b8 vs \u03c9) for Different Scenarios', fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() [My colab code] https://colab.research.google.com/drive/1w2VFAx_vHqH_MjsYttkpVH8_P_HGvs81?usp=sharing","title":"Probelm whit pandelon"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Kepler\u2019s Third Law: Orbital Period and Radius 1. Deriving the Relationship (Kepler\u2019s Third Law) Let\u2019s consider a body (like a satellite or a moon) moving in a circular orbit around a planet. The gravitational force provides the centripetal force: \\[ F_\\text{gravity} = F_\\text{centripetal} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Where: \\(G\\) is the gravitational constant \\(M\\) is the mass of the central body (e.g. Earth) \\(m\\) is the mass of the orbiting object \\(r\\) is the orbital radius \\(v\\) is the orbital velocity Simplifying: \\[ \\frac{G M}{r} = v^2 \\] Now use the relation between velocity and orbital period \\(T\\) : \\[ v = \\frac{2 \\pi r}{T} \\Rightarrow v^2 = \\frac{4 \\pi^2 r^2}{T^2} \\] Substitute this into the gravity equation: \\[ \\frac{G M}{r} = \\frac{4 \\pi^2 r^2}{T^2} \\] Now solve for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] \u2705 Conclusion : $$ T^2 \\propto r^3 $$ This is Kepler's Third Law for circular orbits. 2. Implications in Astronomy Planetary Mass Estimation : By measuring \\(T\\) and \\(r\\) , we can solve for \\(M\\) , the mass of the central planet or star. Distance Calculation : If we know the orbital period, we can estimate the orbital radius and vice versa. Satellite Orbits : Engineers use this law to design satellite orbits for GPS, communications, and weather observation. 3. Real-World Example \u2013 The Moon\u2019s Orbit Distance from Earth: \\(r \\approx 3.84 \\times 10^8 \\, \\text{m}\\) Earth's mass: \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) Using: \\[ T = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\Rightarrow T \\approx 27.3 \\, \\text{days} \\] Which matches the Moon\u2019s actual orbital period. 4. Simulation and Visualization (Summary) A Python script was used to: Simulate circular orbits Plot \\(T^2\\) versus \\(r^3\\) , showing a straight line (confirms Kepler's Law) Compute real orbital periods 5. Extension to Elliptical Orbits For elliptical orbits, replace \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G (M + m)} \\] Where: \\(M\\) and \\(m\\) are the masses of the two bodies This version works for binary stars , exoplanets , and even galactic orbits . Additional Visuals for Kepler's Third Law fig, axs = plt.subplots(2, 2, figsize=(12, 10)) import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg) Orbital radii (m) radii = np.linspace(7e6, 4.2e7, 100) # from ~7000 km to ~42000 km Compute orbital periods using Kepler's 3rd Law for circular orbits T_squared = (4 * np.pi 2 * radii 3) / (G * M) r_cubed = radii**3 Plotting plt.figure(figsize=(10, 6)) plt.plot(r_cubed, T_squared, label='Kepler\u2019s Third Law') plt.title(' \\(T^2\\) vs \\(r^3\\) (Kepler\u2019s Third Law)') plt.xlabel('Orbital Radius Cubed \\(r^3\\) (m\u00b3)') plt.ylabel('Orbital Period Squared \\(T^2\\) (s\u00b2)') plt.grid(True) plt.legend() plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt plt.suptitle(\"Visualizations Supporting Kepler's Third Law\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show() https://colab.research.google.com/drive/14qjrhSdrlgkpfu0Lel1x9ZVsAqHItlZg?usp=sharing","title":"Kepler\u2019s Third Law: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-radius","text":"","title":"Kepler\u2019s Third Law: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-deriving-the-relationship-keplers-third-law","text":"Let\u2019s consider a body (like a satellite or a moon) moving in a circular orbit around a planet. The gravitational force provides the centripetal force: \\[ F_\\text{gravity} = F_\\text{centripetal} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Where: \\(G\\) is the gravitational constant \\(M\\) is the mass of the central body (e.g. Earth) \\(m\\) is the mass of the orbiting object \\(r\\) is the orbital radius \\(v\\) is the orbital velocity Simplifying: \\[ \\frac{G M}{r} = v^2 \\] Now use the relation between velocity and orbital period \\(T\\) : \\[ v = \\frac{2 \\pi r}{T} \\Rightarrow v^2 = \\frac{4 \\pi^2 r^2}{T^2} \\] Substitute this into the gravity equation: \\[ \\frac{G M}{r} = \\frac{4 \\pi^2 r^2}{T^2} \\] Now solve for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] \u2705 Conclusion : $$ T^2 \\propto r^3 $$ This is Kepler's Third Law for circular orbits.","title":"1. Deriving the Relationship (Kepler\u2019s Third Law)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-in-astronomy","text":"Planetary Mass Estimation : By measuring \\(T\\) and \\(r\\) , we can solve for \\(M\\) , the mass of the central planet or star. Distance Calculation : If we know the orbital period, we can estimate the orbital radius and vice versa. Satellite Orbits : Engineers use this law to design satellite orbits for GPS, communications, and weather observation.","title":"2. Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-example-the-moons-orbit","text":"Distance from Earth: \\(r \\approx 3.84 \\times 10^8 \\, \\text{m}\\) Earth's mass: \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) Using: \\[ T = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\Rightarrow T \\approx 27.3 \\, \\text{days} \\] Which matches the Moon\u2019s actual orbital period.","title":"3. Real-World Example \u2013 The Moon\u2019s Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-simulation-and-visualization-summary","text":"A Python script was used to: Simulate circular orbits Plot \\(T^2\\) versus \\(r^3\\) , showing a straight line (confirms Kepler's Law) Compute real orbital periods","title":"4. Simulation and Visualization (Summary)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-to-elliptical-orbits","text":"For elliptical orbits, replace \\(r\\) with the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G (M + m)} \\] Where: \\(M\\) and \\(m\\) are the masses of the two bodies This version works for binary stars , exoplanets , and even galactic orbits .","title":"5. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#additional-visuals-for-keplers-third-law","text":"fig, axs = plt.subplots(2, 2, figsize=(12, 10)) import numpy as np import matplotlib.pyplot as plt","title":"Additional Visuals for Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of the Earth (kg)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-radii-m","text":"radii = np.linspace(7e6, 4.2e7, 100) # from ~7000 km to ~42000 km","title":"Orbital radii (m)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#compute-orbital-periods-using-keplers-3rd-law-for-circular-orbits","text":"T_squared = (4 * np.pi 2 * radii 3) / (G * M) r_cubed = radii**3","title":"Compute orbital periods using Kepler's 3rd Law for circular orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting","text":"plt.figure(figsize=(10, 6)) plt.plot(r_cubed, T_squared, label='Kepler\u2019s Third Law') plt.title(' \\(T^2\\) vs \\(r^3\\) (Kepler\u2019s Third Law)') plt.xlabel('Orbital Radius Cubed \\(r^3\\) (m\u00b3)') plt.ylabel('Orbital Period Squared \\(T^2\\) (s\u00b2)') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"import numpy as np import matplotlib.pyplot as plt plt.suptitle(\"Visualizations Supporting Kepler's Third Law\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show() https://colab.research.google.com/drive/14qjrhSdrlgkpfu0Lel1x9ZVsAqHItlZg?usp=sharing","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"\ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities Theoretical Background First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 = \\sqrt{ \\frac{G M}{r} } \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{ \\frac{2 G M}{r} } \\] Third Cosmic Velocity ( \\(v_3\\) ): \\[ v_{\\text{orbit}} = \\sqrt{ \\frac{G M_{\\odot}}{r_{\\text{orbit}}} } \\] \\[ v_3 = \\sqrt{ v_2^2 + v_{\\text{orbit}}^2 } \\] Where: \\(G\\) : Gravitational constant. \\(M\\) : Mass of the planet. \\(r\\) : Radius of the planet. \\(M_{\\odot}\\) : Mass of the Sun. \\(r_{\\text{orbit}}\\) : Distance of the planet's orbit around the Sun. Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (mass of the Sun) Celestial body data: Mass (kg), Radius (m), Orbit radius (m) bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Mars': [6.417e23, 3.3895e6, 2.279e11], 'Jupiter': [1.898e27, 6.9911e7, 7.785e11] } names = [] v1_list = [] v2_list = [] v3_list = [] for name, (M, r, r_orbit) in bodies.items(): # First Cosmic Velocity (v\u2081) v1 = np.sqrt(G * M / r) # Second Cosmic Velocity (v\u2082) v2 = np.sqrt(2) * v1 # Orbital velocity around the Sun v_orbit = np.sqrt(G * M_sun / r_orbit) # Third Cosmic Velocity (v\u2083) v3 = np.sqrt(v2**2 + v_orbit**2) # Store values (convert to km/s) names.append(name) v1_list.append(v1 / 1000) v2_list.append(v2 / 1000) v3_list.append(v3 / 1000) Plotting x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_list, width, label='First Cosmic Velocity (v\u2081)') plt.bar(x, v2_list, width, label='Second Cosmic Velocity (v\u2082)') plt.bar(x + width, v3_list, width, label='Third Cosmic Velocity (v\u2083)') plt.xticks(x, names) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, axis='y') plt.show() ``` [My colab code] (https://colab.research.google.com/drive/1vXPEEPSD0Y3ibrs5ezf4kH3yBB92C4Ow?usp=sharing)","title":"\ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"\ud83d\ude80 Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-background","text":"First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 = \\sqrt{ \\frac{G M}{r} } \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{ \\frac{2 G M}{r} } \\] Third Cosmic Velocity ( \\(v_3\\) ): \\[ v_{\\text{orbit}} = \\sqrt{ \\frac{G M_{\\odot}}{r_{\\text{orbit}}} } \\] \\[ v_3 = \\sqrt{ v_2^2 + v_{\\text{orbit}}^2 } \\] Where: \\(G\\) : Gravitational constant. \\(M\\) : Mass of the planet. \\(r\\) : Radius of the planet. \\(M_{\\odot}\\) : Mass of the Sun. \\(r_{\\text{orbit}}\\) : Distance of the planet's orbit around the Sun.","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#gravitational-constant","text":"G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (mass of the Sun)","title":"Gravitational constant"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-data-mass-kg-radius-m-orbit-radius-m","text":"bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Mars': [6.417e23, 3.3895e6, 2.279e11], 'Jupiter': [1.898e27, 6.9911e7, 7.785e11] } names = [] v1_list = [] v2_list = [] v3_list = [] for name, (M, r, r_orbit) in bodies.items(): # First Cosmic Velocity (v\u2081) v1 = np.sqrt(G * M / r) # Second Cosmic Velocity (v\u2082) v2 = np.sqrt(2) * v1 # Orbital velocity around the Sun v_orbit = np.sqrt(G * M_sun / r_orbit) # Third Cosmic Velocity (v\u2083) v3 = np.sqrt(v2**2 + v_orbit**2) # Store values (convert to km/s) names.append(name) v1_list.append(v1 / 1000) v2_list.append(v2 / 1000) v3_list.append(v3 / 1000)","title":"Celestial body data: Mass (kg), Radius (m), Orbit radius (m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plotting","text":"x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_list, width, label='First Cosmic Velocity (v\u2081)') plt.bar(x, v2_list, width, label='Second Cosmic Velocity (v\u2082)') plt.bar(x + width, v3_list, width, label='Third Cosmic Velocity (v\u2083)') plt.xticks(x, names) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.legend() plt.grid(True, axis='y') plt.show() ``` [My colab code] (https://colab.research.google.com/drive/1vXPEEPSD0Y3ibrs5ezf4kH3yBB92C4Ow?usp=sharing)","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Projectile Motion: Range as a Function of the Angle of Projection 1. Theoretical Foundation We begin with the basic equations of motion for a projectile launched at angle \\(\\theta\\) with speed \\(v_0\\) , assuming: No air resistance Constant gravitational acceleration \\(g\\) Launch height = 0 Decomposing Motion Horizontal velocity: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical velocity: \\(v_{0y} = v_0 \\sin\\theta\\) Time of flight ( \\(T\\) ) until it hits the ground: \\[ T = \\frac{2v_0 \\sin\\theta}{g} \\] Range \\(R\\) is the horizontal distance traveled: \\[ R = v_{0x} \\cdot T = v_0 \\cos\\theta \\cdot \\frac{2v_0 \\sin\\theta}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the governing equation for range as a function of angle. 2. Analysis of the Range Key Observations Maximum range occurs at \\(\\theta = 45^\\circ\\) since \\(\\sin(2\\theta)\\) reaches its peak at \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\) Effect of Parameters Initial velocity \\(v_0\\) : Range increases quadratically with \\(v_0\\) Gravity \\(g\\) : Range is inversely proportional to \\(g\\) (lower gravity = farther range) 3. Practical Applications This model can apply to: Sports (e.g., soccer, basketball) \u2013 adjusting launch angles for maximum range Engineering (e.g., missile trajectory, water jets) Astrophysics \u2013 modeling orbits and interplanetary trajectories (with modifications) Beyond Ideal Model Real-world considerations: - Air resistance (drag) - Wind - Non-zero launch height - Uneven terrain These factors require numerical integration and more complex models. 4. Implementation: Simulation in Python ```python import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g, angles_deg): angles_rad = np.radians(angles_deg) return (v0**2 * np.sin(2 * angles_rad)) / g Parameters v0 = 50 # m/s g_values = [9.81, 3.71, 1.62] # Earth, Mars, Moon angles = np.linspace(0, 90, 500) Plotting plt.figure(figsize=(10, 6)) for g in g_values: R = compute_range(v0, g, angles) plt.plot(angles, R, label=f'g = {g} m/s\u00b2') plt.title('Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#projectile-motion-range-as-a-function-of-the-angle-of-projection","text":"","title":"Projectile Motion: Range as a Function of the Angle of Projection"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-foundation","text":"We begin with the basic equations of motion for a projectile launched at angle \\(\\theta\\) with speed \\(v_0\\) , assuming: No air resistance Constant gravitational acceleration \\(g\\) Launch height = 0","title":"1. Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#decomposing-motion","text":"Horizontal velocity: \\(v_{0x} = v_0 \\cos\\theta\\) Vertical velocity: \\(v_{0y} = v_0 \\sin\\theta\\) Time of flight ( \\(T\\) ) until it hits the ground: \\[ T = \\frac{2v_0 \\sin\\theta}{g} \\] Range \\(R\\) is the horizontal distance traveled: \\[ R = v_{0x} \\cdot T = v_0 \\cos\\theta \\cdot \\frac{2v_0 \\sin\\theta}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the governing equation for range as a function of angle.","title":"Decomposing Motion"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-observations","text":"Maximum range occurs at \\(\\theta = 45^\\circ\\) since \\(\\sin(2\\theta)\\) reaches its peak at \\(\\theta = 45^\\circ\\) Symmetry: \\(R(\\theta) = R(90^\\circ - \\theta)\\)","title":"Key Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#effect-of-parameters","text":"Initial velocity \\(v_0\\) : Range increases quadratically with \\(v_0\\) Gravity \\(g\\) : Range is inversely proportional to \\(g\\) (lower gravity = farther range)","title":"Effect of Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-practical-applications","text":"This model can apply to: Sports (e.g., soccer, basketball) \u2013 adjusting launch angles for maximum range Engineering (e.g., missile trajectory, water jets) Astrophysics \u2013 modeling orbits and interplanetary trajectories (with modifications)","title":"3. Practical Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/#beyond-ideal-model","text":"Real-world considerations: - Air resistance (drag) - Wind - Non-zero launch height - Uneven terrain These factors require numerical integration and more complex models.","title":"Beyond Ideal Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-implementation-simulation-in-python","text":"```python import numpy as np import matplotlib.pyplot as plt def compute_range(v0, g, angles_deg): angles_rad = np.radians(angles_deg) return (v0**2 * np.sin(2 * angles_rad)) / g","title":"4. Implementation: Simulation in Python"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"v0 = 50 # m/s g_values = [9.81, 3.71, 1.62] # Earth, Mars, Moon angles = np.linspace(0, 90, 500)","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#plotting","text":"plt.figure(figsize=(10, 6)) for g in g_values: R = compute_range(v0, g, angles) plt.plot(angles, R, label=f'g = {g} m/s\u00b2') plt.title('Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"Plotting"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}